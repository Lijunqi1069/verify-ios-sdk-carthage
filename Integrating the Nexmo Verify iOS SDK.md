Integrating the Nexmo Verify iOS SDK
===============================

Using the [Nexmo Verify](https://www.nexmo.com/product/verify/) SDK, you integrate Verify functionality directly into your iOS App:

1. [Prerequisites](#prereq)
2. [Integrate the Verify iOS SDK](#integrate)
3. [GCM Push Integration](#gcm)

## Prerequisites<a name="prereq"></a>

To develop with the Nexmo Verify iOS SDK you need to:

1. Create a __Nexmo Account__. If you don't have one, register at: https://dashboard.nexmo.com/register.
2. In the Nexmo Dashboard, click *Tools* > *Verify SDK*.
3. Add your App information and click *Save*.
4. In the *My Apps* section of the page you see the:
  * An __ID__: a 25 character AlNum that identifies each App that integrates the Nexmo Verify iOS SDK.
  * A __Shared Secret__: a 15 character AlNum generated by the system.
  You use these identifiers so your App can interact with Nexmo services.
    **Note**: these identifiers are completely separate from your Nexmo __Key__ and __Secret__. You MUST NOT embed your Nexmo Key and Secret in your App.

## Integrate the Verify iOS SDK<a name="integrate"></a>

You now integrate the Verify iOS SDK into your App code:

### Include as Embedded Framework

- Add VerifyIosSdk as a submodule by opening the Terminal, `cd`-ing into your top-level project directory, and entering the following command:

```bash
$ git submodule add https://github.com/nexmo/verify-ios-sdk.git
```

- Open the new `verify-ios-sdk` folder, and drag the `VerifyIosSdk.xcodeproj` into the Project Navigator of your application's Xcode project.

    > It should appear nested underneath your applications blue project icon. Whether it is above or below all the other Xcode groups does not matter.

- Select the `VerifyIosSdk.xcodeproj` in the Project Navigator and verify the deployment target matches that of your application target.
- Next, select your application project in the *Project Navigator* (blue project icon) to navigate to the target configuration window and select the application target under the *Targets* heading in the sidebar.
- In the tab bar at the top of that window, open the *General* panel.
- Click on the `+` button under the *Embedded Binaries* section.
- You will two different `VerifyIosSdk.xcodeproj` each containing the files `VerifyIosSdk.framework`, `DeviceProperties.framework` and `RequestSigning.framework`, nested inside a *Products* folder.

    > It does not matter which *Products* folder you choose from.

- Select each of the three files listed above.

    > If you are importing the SDK into an Objective-C based application you must also navigate to your target's Build Settings and enable *Embedded Content Contains Swift Code* under *Build Options*.

- And that's it!

    > The framework files are automagically added as a target dependencies, linked frameworks and embedded frameworks in a copy files build phase which is all you need to build on the simulator and a device.

### Performing a Simple Verification
1. Initialise the Nexmo Client

    **Swift**
    ```swift
    import VerifyIosSdk

    @UIApplicationMain
    class AppDelegate: UIResponder, UIApplicationDelegate {
        
        func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
            // Start up the NexmoClient with your application key(id) and your shared secret key
            NexmoClient.start(applicationId: "abcde", sharedSecretKey: "12345")

            // ..
        }

        // ..
    }

    // ..
    ```

    **Objective-C**
    ```objective-c
    @import VerifyIosSdk;

    @implementation AppDelegate

    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
        // Start up the NexmoClient with your application key(id) and your shared secret key
        [NexmoClient startWithApplicationId:@"abcde" sharedSecretKey:@"12345"];

        // ..
    }

    // ..
    ```

    > **Note**: For the security of your Nexmo account, you should not use your Nexmo Key or Secret in your code.

2. Initiate a verification

    **Swift**
    ```swift
    VerifyClient.getVerifiedUser(countryCode: "GB", phoneNumber: "07000000000",
        onVerifyInProgress: {
            // called when the verification process begins
        },
        onUserVerified: {
            // called when the user has been successfully verified
        },
        onError: { (error: VerifyError) in
            // called when some error occurrs during verification, e.g. wrong pin entered.
            // see the VerifyError class for details on what to expect
        }
    )
    ```

    **Objective-C**
    ```objective-c
    [VerifyClient getVerifiedUserWithCountryCode:@"GB" phoneNumber:@"07000000000"
        verifyInProgressBlock:^{
            // called when the verification process begins
        }
        userVerifiedBlock:^{
            // called when the user has been successfully verified
        }
        errorBlock:^(VerifyError error) {
            // called when some error occurrs during verification, e.g. wrong pin entered.
            // see the VerifyError class for details on what to expect
        }
    ];
    ```
    A new verification is initiated using a supplied `phone number`, optional `country code` and some `callbacks` for verification progress updates. Even if a user enters the phone number with the country code, Verify SDK determines the correctly internationalised phone number.

     * Once the verification process has begun, `OnVerifyInProgress`/`verifyInProgressBlock` is invoked.
     * If verification cannot be started,`onError`/`errorBlock` is instead invoked to describe the error.

3. Supply the PIN code entered by the user to the `checkPinCode` method in your App:

    **Swift**
    ```swift
    VerifyClient.checkPinCode("1234")
    ```

    **Objective-C**
    ```objective-c
    [VerifyClient checkPinCode:@"1234"];
    ```

4. The `onUserVerified`/`userVerifiedBlock` callback is invoked when verification is successful. In the event of an error (for example, invalid pin code), the `onError`/`errorBlock` is instead invoked to describe the error.

    ## GCM Push Integration<a name="gcm"></a>

    In order to configure your Nexmo application for Google Cloud Messaging (GCM):

    1. Obtain an API key from Google Developer Console.
    2. Provide Nexmo with your server API key. We need this to send push messages to your App. You set this value in Nexmo Manager.

        > **Note** This feature is not enabled yet in the Nexmo Dashboard, please contact productfeedback@nexmo.com to configure this.

    3. Enable GCM in your App: [https://developers.google.com/mobile/add]().
    4. Provide your GCM registration token to the NexmoClient: [https://developers.google.com/cloud-messaging/android/client]().
    5. Make sure your App handles the refresh tokens and updates *nexmoClient*.

        **Swift**
        ```swift
        NexmoClient.setGcmToken("MyGCMRegistrationToken");
        ```

        **Objective-C**
        ```objective-c
        [NexmoClient setGcmToken:@"MyGCMRegistrationToken"];
        ```

    6. Let Nexmo handle the pin code notification automatically:

        **Swift**
        ```swift
        if (VerifyClient.handleNotification(userInfo, performSilentCheck: false)) {
            // verification handled successfully
            return
        }
        ```

        **Objective-C**
        ```objective-c
        if ([VerifyClient handleNotificationWithUserInfo:userInfo performSilentCheck:YES]) {
            // verification handled successfully
            return;
        }
        ```

        > The `performSilentCheck` parameter determines whether the verification pin should be automatically checked with the SDK service silently (and the onUserVerified callback triggered), or whether it should be displayed to the user in a popup.

    All push messages have a short lifespan. For example, if a *check* function is not invoked in time, the standard SMS-TTS flow is initiated.

    Push is only available once you have verified yourself at least once on the mobile device.

    > **Note**: never store sensitive user details like the phone number locally. Persisting user information in local storage is not good user security.
